<!DOCTYPE html><html lang="ko"> <head><title>SICP JS - 1.2: 함수와 함수가 생성하는 프로세스</title><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css"><meta charset="utf-8"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v5.7.10"><meta name="description" content="Structure and Interpretion of Computer Programs, JavaScript Edition / Harold Abelson and Gerald Jay Sussman; adapted to JavaScript by Martin Henz and Tobias Wrigstad; with Julie Sussman"><link rel="stylesheet" href="/_astro/_slug_.BbqHp5pO.css"></head> <body class="h_full d_flex flex-d_column"> <nav class="py_4 h_16 c_etainSnowGray ff_serif fs_lg sm:fs_xl md:fs_2xl lg:fs_3xl font-style_italic d_flex jc_center ai_center"> <a href="/" class="td_none hover:td_underline focus:td_underline active:td_underline">Couvoir</a><span class="px_1 sm:px_1 md:px_2 lg:px_2">=</span>f<a href="/playground" class="td_none hover:td_underline focus:td_underline active:td_underline">(playground)</a><a href="/blog" class="td_none hover:td_underline focus:td_underline active:td_underline">(blog)</a><a href="/me" class="td_none hover:td_underline focus:td_underline active:td_underline">(me)</a> </nav> <main class="flex-g_1 d_flex jc_center ai_center"> <div class="min-w_0 w_8xl py_4 px_8 d_flex flex-d_column"> <h1 class="fs_3xl md:fs_4xl lg:fs_5xl fw_bold wb_keep-all">SICP JS - 1.2: 함수와 함수가 생성하는 프로세스</h1> <p class="fs_2xl fw_semibold">2023. 11. 27.</p> <hr class="my_2"> <section class="fw_semibold [&#38;_h2]:wb_keep-all [&#38;_h2]:py_2 [&#38;_h2]:fs_2xl [&#38;_h2]:md:fs_2xl [&#38;_h2]:lg:fs_4xl [&#38;_h3]:wb_keep-all [&#38;_h3]:py_2 [&#38;_h3]:fs_xl [&#38;_h3]:md:fs_xl [&#38;_h3]:lg:fs_3xl [&#38;_h4]:wb_keep-all [&#38;_h4]:py_2 [&#38;_h4]:fs_lg [&#38;_h4]:md:fs_lg [&#38;_h4]:lg:fs_2xl [&#38;_p]:py_4 [&#38;_p]:fs_md [&#38;_p]:md:fs_md [&#38;_p]:lg:fs_xl [&#38;_p]:lh_relaxed [&#38;_p]:[&#38;_code]:px_1 [&#38;_p]:[&#38;_code]:py_0.5 [&#38;_p]:[&#38;_code]:bdr_sm [&#38;_p]:[&#38;_code]:bg-c_torvishDeepSea [&#38;_p]:[&#38;_code]:c_deepOrange [&#38;_ul]:px_10 [&#38;_ul]:py_4 [&#38;_ul]:fs_md [&#38;_ul]:md:fs_md [&#38;_ul]:lg:fs_xl [&#38;_ul]:lh_relaxed [&#38;_ul]:li-t_disc [&#38;_ol]:px_10 [&#38;_ol]:py_4 [&#38;_ol]:fs_md [&#38;_ol]:md:fs_md [&#38;_ol]:lg:fs_xl [&#38;_ol]:lh_relaxed [&#38;_ol]:li-t_decimal [&#38;_pre]:p_4 [&#38;_pre]:bdr_md [&#38;_a]:td_underline">  <p>SICP JS를 읽고, 이미 체득했다고 생각하는 정보들은 제외한 후 기억해둘 만하다 생각한 정보를 나열(정리가 아니다!)하였다.</p>
<!-- more -->
<p>동일한 입력에 대해 동일한 출력을 가지는 함수라고 해도, 그 ‘형태’에 따라서 서로 다른 특징을 따름.</p>
<hr>
<p>프로세스가 실행됨에 따라, ‘<em>지연된 연산</em>의 연쇄’(a chain of <em>deferred operations</em>)를 만들어가며 <strong>확장</strong>된 것을 실제로 계산해나가며 <strong>축소</strong>하는 형태 → <strong>‘재귀적 프로세스’(recursive process)</strong></p>
<ul>
<li>지연된 연산의 연쇄 길이, 즉 결과를 얻기 위해 추적해야 하는 정보량이 입력의 크기에 선형적으로 비례할 때, 이를 **선형 재귀적 프로세스(<em>linear recursive process</em>)**라고 함</li>
<li>결과를 얻기 위해 추적해야 하는 정보가 트리 형태를 이룰 때, 이를 **트리 재귀적 프로세스(<em>tree-recursive process</em>)**라고 하며, 이 때 실행될 단계의 개수는 입력의 크기에 지수적으로 비례하며 필요한 공간은 트리의 높이에 선형적으로 비례함</li>
</ul>
<p>고정된 개수의 상태 변수, 프로세스가 실행됨에 따라 각 상태 변수를 어떻게 갱신할 지에 대한 규칙과 종료 조건을 통해 표현되는 형태 → <strong>‘반복적 프로세스’(<em>iterative process</em>)</strong></p>
<ul>
<li>결과를 얻기 위해 실행될 단계의 개수가 입력의 크기에 선형적으로 비례할 때, 이를 **선형 반복적 프로세스(<em>linear iterative process</em>)**라고 함</li>
</ul>
<p>반복적 프로세스의 경우, 임의 시점에 대한 프로세스의 상태는 상태 변수를 통해 완전하게 표현될 수 있다. 특정 시점에 계산을 멈췄다가 재개하기 위해서는 상태 변수를 제공하기만 하면 된다.</p>
<p>재귀적 프로세스의 경우, 프로세스를 실행하고 있는 주체가 ‘<em>지연된 연산</em>의 연쇄’ 중 어디가 실행되고 있는지에 대한 ‘숨겨진’(코드 상에 드러나지 않는) 정보를 추가적으로 관리한다.</p>
<h4 id="재귀적-프로세스와-재귀-함수를-혼동하지-않도록-주의"><strong>’재귀적 프로세스’와 ‘재귀 함수’를 혼동하지 않도록 주의!</strong></h4>
<hr>
<p>a의 n제곱(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)을 계산할 때, b가 큰 수인 경우 연속제곱법을 이용하여 실행될 단계 개수와 필요한 공간의 크기를 n의 로그 함수(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>)에 비례하게 줄일 수 있다.</p>
<p>두 정수 a와 b(a ≥ b), 그리고 a를 b로 나눈 나머지 r에 대해, a와 b의 최대공약수는 b와 r의 최대공약수와 서로 같으며 이를 이용하여 큰 수의 최대공약수를 효율적으로 구하는 방법을 유클리드 호제법이라고 한다. 이를 위해 필요한 단계의 개수는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>와 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>에 비례한다.</p>
<p>n이 소수가 아니라면 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span></span>보다 작거나 같은 약수를 가지고 있어야 하며, 이러한 사실을 통해 n이 소수임을 판별하기 위해서 필요한 단계의 개수는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span></span>에 비례한다.</p>
<p>n이 소수이고 a가 n보다 작은 양의 정수라면  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>≡</mo><mi>a</mi><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">a^n≡a\mod{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span>이며(페르마의 소정리), 이 정리를 이용하여 소수 여부를 판별하기 위해 필요한 단계의 개수는 경우 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>에 비례한다. 그러나 이 알고리즘은 모든 경우에 대해 올바르지 않으며, 해당 판별법을 거쳤음에도 n이 소수가 아닐 가능성이 존재한다. 이러한 형태의 알고리즘을 ‘확률적 알고리즘’(<em>probabilistic algorithm</em>)이라고 한다.</p>  </section> <hr class="my_2"> <ul class="p_2 fs_lg fw_medium">SICP, SICP JS, 컴퓨터 프로그램의 구조와 해석</ul> </div> </main> <footer class="c_etainSnowGray fs_md sm:fs_md md:fs_lg lg:fs_xl py_4 d_flex flex-d_column jc_center ai_center"> <p>
Powered by <a class="td_none hover:td_underline focus:td_underline active:td_underline" href="https://astro.build">Astro</a>.
</p> <p>
Special thanks to <a class="td_none hover:td_underline focus:td_underline active:td_underline" href="https://lute.fantazm.net/dye">지염도서관</a>, <a class="td_none hover:td_underline focus:td_underline active:td_underline" href="https://crepe.cm/@naega_haenaem_">내가해냄</a>!
</p> </footer> </body></html>